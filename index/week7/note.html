<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Portfolio (by Joseph Hark for WDD 330 BYUI)" />
    <link rel="stylesheet" href="css/notes.css" />
    <title>Portfolio</title>
</head>

<body>
    <header>
        <h1>Portfolio</h1>
        <h3>Joseph Hark</h3>
        <h4>WDD 330</h4>
    </header>
    <main>
        <h2>Chapter 11</h2>
        <p>A useful feature of this is that it provides result caching, ormemoization.

            If a function takes some time to compute a return value, we can save the result in a cache property. Then if
            the same argument is used again later, we can return the value from the cache, rather than having to compute
            the result again. For example, say squaring a number was an expensive computational operation that took a
            long time. We could rewrite the square() function so it saved each result in a cache object that is a
            property of the function:

            function square(x){
            square.cache = square.cache || {};
            if (!square.cache[x]) {
            square.cache[x] = x*x;
            }
            return square.cache[x]
            }</p>
        <p>AnImmediately Invoked Function Expression– or IIFE – (pronounced 'iffy') is an anonymous function that, as
            the name suggests, is invoked as soon as it’s defined. This is easily achieved by placing parentheses at the
            end of the function definition (remember we use parentheses to invoke a function). The function also has to
            be made into an expression, which is done by placing the whole declaration inside parentheses, as in this
            example:

            (function(){
            const temp = 'World';
            console.log(`Hello ${temp}`);
            })();</p>
        <p>The dynamic nature of JavaScript means that a function is able to not only call itself, but define itself,
            and even redefine itself. This is done by assigning an anonymous function to a variable that has the same
            name as the function.

            Consider the following function:
            <br>
            function party(){
            console.log('Wow this is amazing!');
            party = function(){
            console.log('Been there, got the T-Shirt');
            }
            }
            <br>
            This logs a message in the console, then redefines itself to log a different message in the console. When
            the function has been called once, it will be as if it was defined like this:
            <br>
            function party() {
            console.log('Been there, got the T-Shirt');
            }
            <br>
            Every time the function is called after the first time, it will log the message 'Been there, got the
            T-Shirt':

            party();
            'Wow this is amazing!'
            party();
            'Been there, got the T-Shirt'
            party();
            'Been there, got the T-Shirt'
            <br>
            If the function is also assigned to another variable, this variable will maintain the original function
            definition and not be rewritten. This is because the original function is assigned to a variable, then
            within the function, a variable with the same name as the function is assigned to a different function. You
            can see an example of this if we create a variable called beachParty that is assigned to the party()
            function before it is called for the first time and redefined:
            <br>
            function party(){
            console.log('Wow this is amazing!');
            party = function(){
            console.log('Been there, got the T-Shirt');
            }
            }
            const beachParty = party; // note that the party function has not been invoked
            beachParty(); // the party() function has now been redefined, even though it hasn't been called explicitly
            'Wow this is amazing!'
            party();
            'Been there, got the T-Shirt'
            beachParty(); // but this function hasn't been redefined
            'Wow this is amazing!'
            beachParty(); // no matter how many times this is called it will remain the same
            'Wow this is amazing!'</p>

        <p>If any properties have previously been set on the function, these will be lost when the function redefines
            itself. In the previous example, we can set a music property, and see that it no longer exists after the
            function has been invoked and redefined:
            <br>
            function party() {
            console.log('Wow this is amazing!');
            party = function(){
            console.log('Been there, got the T-Shirt');
            }
            }
            party.music = 'Classical Jazz'; // set a property of the function
            party();
            "Wow this is amazing!"
            party.music; // function has now been redefined, so the property doesn't exist
            undefined</p>
        <p>The code example above uses theerror-firstcallback style popularized by Node.js. In this coding pattern,
            callbacks have two arguments. The first is the error argument, which is an error object provided if
            something goes wrong when completing the operation. The second argument is any data returned by the
            operation that can be used in the body of the callback.</p>
        <p>A function is said to be curried when not all arguments have been supplied to the function, so it returns
            another function that retains the arguments already provided, and expects the remaining arguments that were
            omitted when the original function was called. A final result is only returned once all the expected
            arguments have eventually been provided.
        </p>
        <br>
        <br>
        <h2>Chapter 13</h2>
        <p>JavaScript was originally designed as a client-side scripting language, meaning that it ran locally in the
            browser, adding dynamic features to the web page that was returned from the server. Ajax allows JavaScript
            to request resources from a server on behalf of the client. The resources requested are usually JSON data or
            small fragments of text or HTML rather than a whole web page.

            Consequently, a server is required when requesting resources using Ajax. Typically this involves using a
            server-side language, such as PHP, Ruby, Node.js, or .NET to serve the data response following an Ajax
            request (usually from a back-end database). </p>

        <p>The same-origin policy in browsers blocks all requests from a domain that is different from the page making
            the request. This policy is enforced by all modern browsers and is to stop any malicious JavaScript being
            run from an external source. The problem is that the APIs of many websites rely on data being transferred
            across domains.

            Cross-origin resource sharing (CORS)is a solution to this problem as it allows resources to be requested
            from another website outside the original domain. The CORS standard works by using HTTP headers to indicate
            which domains can receive data. A website can have the necessary information in its headers to allow
            external sites access to its API data. Most modern browsers support this method and respect the restrictions
            specified in the headers.</p>
        <p>The same-origin policy in browsers blocks all requests from a domain that is different from the page making
            the request. This policy is enforced by all modern browsers and is to stop any malicious JavaScript being
            run from an external source. The problem is that the APIs of many websites rely on data being transferred
            across domains.

            Cross-origin resource sharing (CORS)is a solution to this problem as it allows resources to be requested
            from another website outside the original domain. The CORS standard works by using HTTP headers to indicate
            which domains can receive data. A website can have the necessary information in its headers to allow
            external sites access to its API data. Most modern browsers support this method and respect the restrictions
            specified in the headers.</p>
        <p>url – The URL of the requested resource (the only property that is required).<br>
            method – a string that specifies which HTTP method should be used for the request. By default, this is
            'GET'.<br>
            headers – This is a Headers object (see later section) that provides details of the request's headers.<br>
            mode – Allows you to specify if CORS is used or not. CORS is enabled by default.<br>
            cache – Allows you to specify how the request will use the browser's cache. For example, you can force it to
            request a resource and update the cache with the result, or you can force it to only look in the cache for
            the resource.<br>
            credentials – Lets you specify if cookies should be allowed with the request.<br>
            redirect – Specifies what to do if the response returns a redirect. There’s a choice of three values:
            'follow' (the redirect is followed), 'error' (an error is thrown) or 'manual' (the user has to click on a
            link to follow the redirect).</p>
        <p>The Web is built upon the Hypertext Transfer Protocol, or HTTP. When a client (usually a browser) makes a
            request to a server, it contains information about which HTTP verb to use.HTTP verbs, also known as HTTP
            methodsare the what HTTP uses to tell the server what type of request is being made, which then determines
            the server will deal with the request.

            The five most commonly used verbs when dealing with resources on the web are:

            GET requests to retrieve resourcesThe Web is built upon the Hypertext Transfer Protocol, or HTTP. When a
            client (usually a browser) makes a request to a server, it contains information about which HTTP verb to
            use.HTTP verbs, also known as HTTP methodsare the what HTTP uses to tell the server what type of request is
            being made, which then determines the server will deal with the request.

            The five most commonly used verbs when dealing with resources on the web are:

            GET requests to retrieve resources <br>

            POST requests, usually used to create a resource but can actually perform any task<br>

            PUT requests toupsert, which means insert a resource or update it entirely<br>

            PATCH requests to make partial updates to a resource<br>

            DELETE requests to delete a resources.<br>

            By default, a link in a web page will make a GET request. Forms are also submitted using a GET request by
            default, but they will often use a POST request.

            POST requests, usually used to create a resource but can actually perform any task

            PUT requests toupsert, which means insert a resource or update it entirely

            PATCH requests to make partial updates to a resource

            DELETE requests to delete a resources.

            By default, a link in a web page will make a GET request. Forms are also submitted using a GET request by
            default, but they will often use a POST request.</p>

    </main>
    <footer>

    </footer>
</body>


</html>